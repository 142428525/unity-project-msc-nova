@<|
label('tut01', '教程1 文字与脚本结构')
is_unlocked_start()
|>
<|
stop(bgm)
set_box()
|>
教程1 文字与脚本结构

看这些教程的时候，最好把Unity里的运行情况与Scenarios文件夹里的脚本对照着看

写在这里的文字会在游戏里显示出来

想要点击鼠标显示下一段文字，就要在两段文字之间空一行


多空几行也不是不行，但是会让脚本比较难看

如果没有空行
就会把两行文字一起显示出来

想要在一起显示的文字当中加空行
<noparse></noparse>
可以用一个空的XML标记（教程4会详细讲XML标记）

王二宫：：两个中文冒号用来分隔说话人的名字和说话的内容

张浅野::也可以用两个英文冒号

<|
print('111')
|>
在文字的上面可以用`<| ... |>`插入一个Lua代码块。上面的代码会在Unity Editor的Console窗口中输出“111”

顺便说一句：：上面的代码块与文字之间没有空行。如果有空行的话……

<|
print('222')
|>

就是先点一下鼠标运行代码（同时对话框变成空的），再点一下鼠标显示文字

我们把两个空行之间的东西（可能包括文本和代码块）叫做一“条”对话（dialogue entry）

顺便说一句：：不管有没有角色在说话，我们都把它叫做一条“对话”
@<| jump_to 'tut01_2' |>

@<|
label 'tut01_2'
|>
一个游戏的脚本可以划分为许多个节点（node），每个节点里可以有许多条对话

每个节点的开头和结尾处各有一个提前代码块（eager execution block），语法为`@<| ... |>`

顺便说一句：：一条对话中的代码块其实叫做延迟代码块（lazy execution block）。提前代码块在parse脚本时执行，延迟代码块则在游戏过程中执行

<noparse><</noparse><noparse>|</noparse>和<noparse>@<</noparse><noparse>|</noparse>不能出现在一行文本的开头

一行文本的结尾不能出现<noparse>|</noparse><noparse>></noparse>

<noparse>：</noparse><noparse>：</noparse>和<noparse>:</noparse><noparse>:</noparse>也不能出现在文本中

它们都是Nova脚本的保留字，如果一定要出现，可以用XML标记把它们拆开（因为Nova先来parse这些保留字，TextMeshPro再来parse XML）

节点开头的提前代码块当中必须有一个`label`函数，定义这个节点的名称

比如我们现在所在的节点的名称是`tut01_2`，上面那个节点的名称则是`tut01`

这里的“名称”是给程序内部使用的。我们还可以定义一个“显示名称”，在存档界面等地方显示给玩家看

比如上面那个节点的开头有`label('tut01', '教程1 文字与脚本结构')`，所以名称是`tut01`，显示名称则是“教程1 文字与脚本结构”

顺便说一句：：Lua中的函数如果只有一个参数，并且参数是string literal或者table constructor，那么函数的括号可以省略（详见[Lua官网](https://www.lua.org/pil/5.html)）

而这个节点的开头只有`label 'tut01_2'`，那么显示名称默认与（同一个文件中的）上面的节点相同。你可以在存档界面里看看
@<| jump_to 'tut01_3' |>

@<|
label('tut01_3', '教程1的后半部分')
|>
现在我们又定义了一个节点，并且改变了显示名称

如果一段剧情比较长，可以把它拆成好几个节点，还可以放到好几个txt文件里

节点的名称必须各不相同，而显示名称可以相同，这样玩家就不会注意到脚本当中其实有好几个节点

节点开头的提前代码块当中，还需要定义剧情入口，也就是这个节点会不会显示在章节选择界面里

`is_start`表示这个节点是剧情入口，在游戏中走到这个节点之后就会在章节选择界面中解锁

`is_unlocked_start`表示这个节点是剧情入口，而且一开始就解锁了

`is_default_start`表示这个节点是默认的剧情入口

如果你不需要章节选择界面，可以只在第一个节点中设置`is_default_start`，其他节点中都不设置剧情入口

而在节点结尾的提前代码块当中，一般要有一个`jump_to`函数，定义跳转到的节点的名称

如果剧情结束了，则要用`is_end`函数

顺便说一句：：至于分支选项怎么做，以后再讲

修改脚本之后，在游戏中按R可以重新加载脚本，而不用重新开始游戏（可能有一些bug，这时候还是要重新开始游戏。。）

这个功能在Unity Editor里才有效，游戏打包出来之后就没有了

在你开始改脚本之前，需要删除英文版脚本，否则中文与英文的脚本会对不上（详见[GitHub上面的使用说明](https://github.com/Lunatic-Works/Nova)）

教程1 文字与脚本结构 到此结束
@<| jump_to 'tut02' |>
